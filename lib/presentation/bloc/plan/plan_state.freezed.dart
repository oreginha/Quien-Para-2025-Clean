// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'plan_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$PlanState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PlanEntity plan) loaded,
    required TResult Function(PlanEntity? plan) saving,
    required TResult Function(PlanEntity? plan) updating,
    required TResult Function(List<PlanEntity> plans) plansLoaded,
    required TResult Function(PlanEntity plan) saved,
    required TResult Function(String message, PlanEntity? plan) error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PlanEntity plan)? loaded,
    TResult? Function(PlanEntity? plan)? saving,
    TResult? Function(PlanEntity? plan)? updating,
    TResult? Function(List<PlanEntity> plans)? plansLoaded,
    TResult? Function(PlanEntity plan)? saved,
    TResult? Function(String message, PlanEntity? plan)? error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PlanEntity plan)? loaded,
    TResult Function(PlanEntity? plan)? saving,
    TResult Function(PlanEntity? plan)? updating,
    TResult Function(List<PlanEntity> plans)? plansLoaded,
    TResult Function(PlanEntity plan)? saved,
    TResult Function(String message, PlanEntity? plan)? error,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlanInitial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(PlanLoaded value) loaded,
    required TResult Function(PlanSaving value) saving,
    required TResult Function(PlanUpdating value) updating,
    required TResult Function(PlansLoaded value) plansLoaded,
    required TResult Function(PlanSaved value) saved,
    required TResult Function(PlanError value) error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlanInitial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(PlanLoaded value)? loaded,
    TResult? Function(PlanSaving value)? saving,
    TResult? Function(PlanUpdating value)? updating,
    TResult? Function(PlansLoaded value)? plansLoaded,
    TResult? Function(PlanSaved value)? saved,
    TResult? Function(PlanError value)? error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlanInitial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(PlanLoaded value)? loaded,
    TResult Function(PlanSaving value)? saving,
    TResult Function(PlanUpdating value)? updating,
    TResult Function(PlansLoaded value)? plansLoaded,
    TResult Function(PlanSaved value)? saved,
    TResult Function(PlanError value)? error,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlanStateCopyWith<$Res> {
  factory $PlanStateCopyWith(PlanState value, $Res Function(PlanState) then) =
      _$PlanStateCopyWithImpl<$Res, PlanState>;
}

/// @nodoc
class _$PlanStateCopyWithImpl<$Res, $Val extends PlanState>
    implements $PlanStateCopyWith<$Res> {
  _$PlanStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$PlanInitialImplCopyWith<$Res> {
  factory _$$PlanInitialImplCopyWith(
    _$PlanInitialImpl value,
    $Res Function(_$PlanInitialImpl) then,
  ) = __$$PlanInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PlanInitialImplCopyWithImpl<$Res>
    extends _$PlanStateCopyWithImpl<$Res, _$PlanInitialImpl>
    implements _$$PlanInitialImplCopyWith<$Res> {
  __$$PlanInitialImplCopyWithImpl(
    _$PlanInitialImpl _value,
    $Res Function(_$PlanInitialImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PlanInitialImpl extends PlanInitial {
  const _$PlanInitialImpl() : super._();

  @override
  String toString() {
    return 'PlanState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PlanInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PlanEntity plan) loaded,
    required TResult Function(PlanEntity? plan) saving,
    required TResult Function(PlanEntity? plan) updating,
    required TResult Function(List<PlanEntity> plans) plansLoaded,
    required TResult Function(PlanEntity plan) saved,
    required TResult Function(String message, PlanEntity? plan) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PlanEntity plan)? loaded,
    TResult? Function(PlanEntity? plan)? saving,
    TResult? Function(PlanEntity? plan)? updating,
    TResult? Function(List<PlanEntity> plans)? plansLoaded,
    TResult? Function(PlanEntity plan)? saved,
    TResult? Function(String message, PlanEntity? plan)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PlanEntity plan)? loaded,
    TResult Function(PlanEntity? plan)? saving,
    TResult Function(PlanEntity? plan)? updating,
    TResult Function(List<PlanEntity> plans)? plansLoaded,
    TResult Function(PlanEntity plan)? saved,
    TResult Function(String message, PlanEntity? plan)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlanInitial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(PlanLoaded value) loaded,
    required TResult Function(PlanSaving value) saving,
    required TResult Function(PlanUpdating value) updating,
    required TResult Function(PlansLoaded value) plansLoaded,
    required TResult Function(PlanSaved value) saved,
    required TResult Function(PlanError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlanInitial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(PlanLoaded value)? loaded,
    TResult? Function(PlanSaving value)? saving,
    TResult? Function(PlanUpdating value)? updating,
    TResult? Function(PlansLoaded value)? plansLoaded,
    TResult? Function(PlanSaved value)? saved,
    TResult? Function(PlanError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlanInitial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(PlanLoaded value)? loaded,
    TResult Function(PlanSaving value)? saving,
    TResult Function(PlanUpdating value)? updating,
    TResult Function(PlansLoaded value)? plansLoaded,
    TResult Function(PlanSaved value)? saved,
    TResult Function(PlanError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class PlanInitial extends PlanState {
  const factory PlanInitial() = _$PlanInitialImpl;
  const PlanInitial._() : super._();
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
    _$LoadingImpl value,
    $Res Function(_$LoadingImpl) then,
  ) = __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$PlanStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
    _$LoadingImpl _value,
    $Res Function(_$LoadingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingImpl extends _Loading {
  const _$LoadingImpl() : super._();

  @override
  String toString() {
    return 'PlanState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PlanEntity plan) loaded,
    required TResult Function(PlanEntity? plan) saving,
    required TResult Function(PlanEntity? plan) updating,
    required TResult Function(List<PlanEntity> plans) plansLoaded,
    required TResult Function(PlanEntity plan) saved,
    required TResult Function(String message, PlanEntity? plan) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PlanEntity plan)? loaded,
    TResult? Function(PlanEntity? plan)? saving,
    TResult? Function(PlanEntity? plan)? updating,
    TResult? Function(List<PlanEntity> plans)? plansLoaded,
    TResult? Function(PlanEntity plan)? saved,
    TResult? Function(String message, PlanEntity? plan)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PlanEntity plan)? loaded,
    TResult Function(PlanEntity? plan)? saving,
    TResult Function(PlanEntity? plan)? updating,
    TResult Function(List<PlanEntity> plans)? plansLoaded,
    TResult Function(PlanEntity plan)? saved,
    TResult Function(String message, PlanEntity? plan)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlanInitial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(PlanLoaded value) loaded,
    required TResult Function(PlanSaving value) saving,
    required TResult Function(PlanUpdating value) updating,
    required TResult Function(PlansLoaded value) plansLoaded,
    required TResult Function(PlanSaved value) saved,
    required TResult Function(PlanError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlanInitial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(PlanLoaded value)? loaded,
    TResult? Function(PlanSaving value)? saving,
    TResult? Function(PlanUpdating value)? updating,
    TResult? Function(PlansLoaded value)? plansLoaded,
    TResult? Function(PlanSaved value)? saved,
    TResult? Function(PlanError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlanInitial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(PlanLoaded value)? loaded,
    TResult Function(PlanSaving value)? saving,
    TResult Function(PlanUpdating value)? updating,
    TResult Function(PlansLoaded value)? plansLoaded,
    TResult Function(PlanSaved value)? saved,
    TResult Function(PlanError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading extends PlanState {
  const factory _Loading() = _$LoadingImpl;
  const _Loading._() : super._();
}

/// @nodoc
abstract class _$$PlanLoadedImplCopyWith<$Res> {
  factory _$$PlanLoadedImplCopyWith(
    _$PlanLoadedImpl value,
    $Res Function(_$PlanLoadedImpl) then,
  ) = __$$PlanLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PlanEntity plan});
}

/// @nodoc
class __$$PlanLoadedImplCopyWithImpl<$Res>
    extends _$PlanStateCopyWithImpl<$Res, _$PlanLoadedImpl>
    implements _$$PlanLoadedImplCopyWith<$Res> {
  __$$PlanLoadedImplCopyWithImpl(
    _$PlanLoadedImpl _value,
    $Res Function(_$PlanLoadedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? plan = null}) {
    return _then(
      _$PlanLoadedImpl(
        plan: null == plan
            ? _value.plan
            : plan // ignore: cast_nullable_to_non_nullable
                  as PlanEntity,
      ),
    );
  }
}

/// @nodoc

class _$PlanLoadedImpl extends PlanLoaded {
  const _$PlanLoadedImpl({required this.plan}) : super._();

  @override
  final PlanEntity plan;

  @override
  String toString() {
    return 'PlanState.loaded(plan: $plan)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlanLoadedImpl &&
            (identical(other.plan, plan) || other.plan == plan));
  }

  @override
  int get hashCode => Object.hash(runtimeType, plan);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PlanLoadedImplCopyWith<_$PlanLoadedImpl> get copyWith =>
      __$$PlanLoadedImplCopyWithImpl<_$PlanLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PlanEntity plan) loaded,
    required TResult Function(PlanEntity? plan) saving,
    required TResult Function(PlanEntity? plan) updating,
    required TResult Function(List<PlanEntity> plans) plansLoaded,
    required TResult Function(PlanEntity plan) saved,
    required TResult Function(String message, PlanEntity? plan) error,
  }) {
    return loaded(plan);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PlanEntity plan)? loaded,
    TResult? Function(PlanEntity? plan)? saving,
    TResult? Function(PlanEntity? plan)? updating,
    TResult? Function(List<PlanEntity> plans)? plansLoaded,
    TResult? Function(PlanEntity plan)? saved,
    TResult? Function(String message, PlanEntity? plan)? error,
  }) {
    return loaded?.call(plan);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PlanEntity plan)? loaded,
    TResult Function(PlanEntity? plan)? saving,
    TResult Function(PlanEntity? plan)? updating,
    TResult Function(List<PlanEntity> plans)? plansLoaded,
    TResult Function(PlanEntity plan)? saved,
    TResult Function(String message, PlanEntity? plan)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(plan);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlanInitial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(PlanLoaded value) loaded,
    required TResult Function(PlanSaving value) saving,
    required TResult Function(PlanUpdating value) updating,
    required TResult Function(PlansLoaded value) plansLoaded,
    required TResult Function(PlanSaved value) saved,
    required TResult Function(PlanError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlanInitial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(PlanLoaded value)? loaded,
    TResult? Function(PlanSaving value)? saving,
    TResult? Function(PlanUpdating value)? updating,
    TResult? Function(PlansLoaded value)? plansLoaded,
    TResult? Function(PlanSaved value)? saved,
    TResult? Function(PlanError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlanInitial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(PlanLoaded value)? loaded,
    TResult Function(PlanSaving value)? saving,
    TResult Function(PlanUpdating value)? updating,
    TResult Function(PlansLoaded value)? plansLoaded,
    TResult Function(PlanSaved value)? saved,
    TResult Function(PlanError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class PlanLoaded extends PlanState {
  const factory PlanLoaded({required final PlanEntity plan}) = _$PlanLoadedImpl;
  const PlanLoaded._() : super._();

  PlanEntity get plan;

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PlanLoadedImplCopyWith<_$PlanLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlanSavingImplCopyWith<$Res> {
  factory _$$PlanSavingImplCopyWith(
    _$PlanSavingImpl value,
    $Res Function(_$PlanSavingImpl) then,
  ) = __$$PlanSavingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PlanEntity? plan});
}

/// @nodoc
class __$$PlanSavingImplCopyWithImpl<$Res>
    extends _$PlanStateCopyWithImpl<$Res, _$PlanSavingImpl>
    implements _$$PlanSavingImplCopyWith<$Res> {
  __$$PlanSavingImplCopyWithImpl(
    _$PlanSavingImpl _value,
    $Res Function(_$PlanSavingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? plan = freezed}) {
    return _then(
      _$PlanSavingImpl(
        plan: freezed == plan
            ? _value.plan
            : plan // ignore: cast_nullable_to_non_nullable
                  as PlanEntity?,
      ),
    );
  }
}

/// @nodoc

class _$PlanSavingImpl extends PlanSaving {
  const _$PlanSavingImpl({this.plan}) : super._();

  @override
  final PlanEntity? plan;

  @override
  String toString() {
    return 'PlanState.saving(plan: $plan)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlanSavingImpl &&
            (identical(other.plan, plan) || other.plan == plan));
  }

  @override
  int get hashCode => Object.hash(runtimeType, plan);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PlanSavingImplCopyWith<_$PlanSavingImpl> get copyWith =>
      __$$PlanSavingImplCopyWithImpl<_$PlanSavingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PlanEntity plan) loaded,
    required TResult Function(PlanEntity? plan) saving,
    required TResult Function(PlanEntity? plan) updating,
    required TResult Function(List<PlanEntity> plans) plansLoaded,
    required TResult Function(PlanEntity plan) saved,
    required TResult Function(String message, PlanEntity? plan) error,
  }) {
    return saving(plan);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PlanEntity plan)? loaded,
    TResult? Function(PlanEntity? plan)? saving,
    TResult? Function(PlanEntity? plan)? updating,
    TResult? Function(List<PlanEntity> plans)? plansLoaded,
    TResult? Function(PlanEntity plan)? saved,
    TResult? Function(String message, PlanEntity? plan)? error,
  }) {
    return saving?.call(plan);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PlanEntity plan)? loaded,
    TResult Function(PlanEntity? plan)? saving,
    TResult Function(PlanEntity? plan)? updating,
    TResult Function(List<PlanEntity> plans)? plansLoaded,
    TResult Function(PlanEntity plan)? saved,
    TResult Function(String message, PlanEntity? plan)? error,
    required TResult orElse(),
  }) {
    if (saving != null) {
      return saving(plan);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlanInitial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(PlanLoaded value) loaded,
    required TResult Function(PlanSaving value) saving,
    required TResult Function(PlanUpdating value) updating,
    required TResult Function(PlansLoaded value) plansLoaded,
    required TResult Function(PlanSaved value) saved,
    required TResult Function(PlanError value) error,
  }) {
    return saving(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlanInitial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(PlanLoaded value)? loaded,
    TResult? Function(PlanSaving value)? saving,
    TResult? Function(PlanUpdating value)? updating,
    TResult? Function(PlansLoaded value)? plansLoaded,
    TResult? Function(PlanSaved value)? saved,
    TResult? Function(PlanError value)? error,
  }) {
    return saving?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlanInitial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(PlanLoaded value)? loaded,
    TResult Function(PlanSaving value)? saving,
    TResult Function(PlanUpdating value)? updating,
    TResult Function(PlansLoaded value)? plansLoaded,
    TResult Function(PlanSaved value)? saved,
    TResult Function(PlanError value)? error,
    required TResult orElse(),
  }) {
    if (saving != null) {
      return saving(this);
    }
    return orElse();
  }
}

abstract class PlanSaving extends PlanState {
  const factory PlanSaving({final PlanEntity? plan}) = _$PlanSavingImpl;
  const PlanSaving._() : super._();

  PlanEntity? get plan;

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PlanSavingImplCopyWith<_$PlanSavingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlanUpdatingImplCopyWith<$Res> {
  factory _$$PlanUpdatingImplCopyWith(
    _$PlanUpdatingImpl value,
    $Res Function(_$PlanUpdatingImpl) then,
  ) = __$$PlanUpdatingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PlanEntity? plan});
}

/// @nodoc
class __$$PlanUpdatingImplCopyWithImpl<$Res>
    extends _$PlanStateCopyWithImpl<$Res, _$PlanUpdatingImpl>
    implements _$$PlanUpdatingImplCopyWith<$Res> {
  __$$PlanUpdatingImplCopyWithImpl(
    _$PlanUpdatingImpl _value,
    $Res Function(_$PlanUpdatingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? plan = freezed}) {
    return _then(
      _$PlanUpdatingImpl(
        plan: freezed == plan
            ? _value.plan
            : plan // ignore: cast_nullable_to_non_nullable
                  as PlanEntity?,
      ),
    );
  }
}

/// @nodoc

class _$PlanUpdatingImpl extends PlanUpdating {
  const _$PlanUpdatingImpl({this.plan}) : super._();

  @override
  final PlanEntity? plan;

  @override
  String toString() {
    return 'PlanState.updating(plan: $plan)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlanUpdatingImpl &&
            (identical(other.plan, plan) || other.plan == plan));
  }

  @override
  int get hashCode => Object.hash(runtimeType, plan);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PlanUpdatingImplCopyWith<_$PlanUpdatingImpl> get copyWith =>
      __$$PlanUpdatingImplCopyWithImpl<_$PlanUpdatingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PlanEntity plan) loaded,
    required TResult Function(PlanEntity? plan) saving,
    required TResult Function(PlanEntity? plan) updating,
    required TResult Function(List<PlanEntity> plans) plansLoaded,
    required TResult Function(PlanEntity plan) saved,
    required TResult Function(String message, PlanEntity? plan) error,
  }) {
    return updating(plan);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PlanEntity plan)? loaded,
    TResult? Function(PlanEntity? plan)? saving,
    TResult? Function(PlanEntity? plan)? updating,
    TResult? Function(List<PlanEntity> plans)? plansLoaded,
    TResult? Function(PlanEntity plan)? saved,
    TResult? Function(String message, PlanEntity? plan)? error,
  }) {
    return updating?.call(plan);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PlanEntity plan)? loaded,
    TResult Function(PlanEntity? plan)? saving,
    TResult Function(PlanEntity? plan)? updating,
    TResult Function(List<PlanEntity> plans)? plansLoaded,
    TResult Function(PlanEntity plan)? saved,
    TResult Function(String message, PlanEntity? plan)? error,
    required TResult orElse(),
  }) {
    if (updating != null) {
      return updating(plan);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlanInitial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(PlanLoaded value) loaded,
    required TResult Function(PlanSaving value) saving,
    required TResult Function(PlanUpdating value) updating,
    required TResult Function(PlansLoaded value) plansLoaded,
    required TResult Function(PlanSaved value) saved,
    required TResult Function(PlanError value) error,
  }) {
    return updating(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlanInitial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(PlanLoaded value)? loaded,
    TResult? Function(PlanSaving value)? saving,
    TResult? Function(PlanUpdating value)? updating,
    TResult? Function(PlansLoaded value)? plansLoaded,
    TResult? Function(PlanSaved value)? saved,
    TResult? Function(PlanError value)? error,
  }) {
    return updating?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlanInitial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(PlanLoaded value)? loaded,
    TResult Function(PlanSaving value)? saving,
    TResult Function(PlanUpdating value)? updating,
    TResult Function(PlansLoaded value)? plansLoaded,
    TResult Function(PlanSaved value)? saved,
    TResult Function(PlanError value)? error,
    required TResult orElse(),
  }) {
    if (updating != null) {
      return updating(this);
    }
    return orElse();
  }
}

abstract class PlanUpdating extends PlanState {
  const factory PlanUpdating({final PlanEntity? plan}) = _$PlanUpdatingImpl;
  const PlanUpdating._() : super._();

  PlanEntity? get plan;

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PlanUpdatingImplCopyWith<_$PlanUpdatingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlansLoadedImplCopyWith<$Res> {
  factory _$$PlansLoadedImplCopyWith(
    _$PlansLoadedImpl value,
    $Res Function(_$PlansLoadedImpl) then,
  ) = __$$PlansLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<PlanEntity> plans});
}

/// @nodoc
class __$$PlansLoadedImplCopyWithImpl<$Res>
    extends _$PlanStateCopyWithImpl<$Res, _$PlansLoadedImpl>
    implements _$$PlansLoadedImplCopyWith<$Res> {
  __$$PlansLoadedImplCopyWithImpl(
    _$PlansLoadedImpl _value,
    $Res Function(_$PlansLoadedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? plans = null}) {
    return _then(
      _$PlansLoadedImpl(
        plans: null == plans
            ? _value._plans
            : plans // ignore: cast_nullable_to_non_nullable
                  as List<PlanEntity>,
      ),
    );
  }
}

/// @nodoc

class _$PlansLoadedImpl extends PlansLoaded {
  const _$PlansLoadedImpl({required final List<PlanEntity> plans})
    : _plans = plans,
      super._();

  final List<PlanEntity> _plans;
  @override
  List<PlanEntity> get plans {
    if (_plans is EqualUnmodifiableListView) return _plans;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_plans);
  }

  @override
  String toString() {
    return 'PlanState.plansLoaded(plans: $plans)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlansLoadedImpl &&
            const DeepCollectionEquality().equals(other._plans, _plans));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_plans));

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PlansLoadedImplCopyWith<_$PlansLoadedImpl> get copyWith =>
      __$$PlansLoadedImplCopyWithImpl<_$PlansLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PlanEntity plan) loaded,
    required TResult Function(PlanEntity? plan) saving,
    required TResult Function(PlanEntity? plan) updating,
    required TResult Function(List<PlanEntity> plans) plansLoaded,
    required TResult Function(PlanEntity plan) saved,
    required TResult Function(String message, PlanEntity? plan) error,
  }) {
    return plansLoaded(plans);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PlanEntity plan)? loaded,
    TResult? Function(PlanEntity? plan)? saving,
    TResult? Function(PlanEntity? plan)? updating,
    TResult? Function(List<PlanEntity> plans)? plansLoaded,
    TResult? Function(PlanEntity plan)? saved,
    TResult? Function(String message, PlanEntity? plan)? error,
  }) {
    return plansLoaded?.call(plans);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PlanEntity plan)? loaded,
    TResult Function(PlanEntity? plan)? saving,
    TResult Function(PlanEntity? plan)? updating,
    TResult Function(List<PlanEntity> plans)? plansLoaded,
    TResult Function(PlanEntity plan)? saved,
    TResult Function(String message, PlanEntity? plan)? error,
    required TResult orElse(),
  }) {
    if (plansLoaded != null) {
      return plansLoaded(plans);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlanInitial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(PlanLoaded value) loaded,
    required TResult Function(PlanSaving value) saving,
    required TResult Function(PlanUpdating value) updating,
    required TResult Function(PlansLoaded value) plansLoaded,
    required TResult Function(PlanSaved value) saved,
    required TResult Function(PlanError value) error,
  }) {
    return plansLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlanInitial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(PlanLoaded value)? loaded,
    TResult? Function(PlanSaving value)? saving,
    TResult? Function(PlanUpdating value)? updating,
    TResult? Function(PlansLoaded value)? plansLoaded,
    TResult? Function(PlanSaved value)? saved,
    TResult? Function(PlanError value)? error,
  }) {
    return plansLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlanInitial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(PlanLoaded value)? loaded,
    TResult Function(PlanSaving value)? saving,
    TResult Function(PlanUpdating value)? updating,
    TResult Function(PlansLoaded value)? plansLoaded,
    TResult Function(PlanSaved value)? saved,
    TResult Function(PlanError value)? error,
    required TResult orElse(),
  }) {
    if (plansLoaded != null) {
      return plansLoaded(this);
    }
    return orElse();
  }
}

abstract class PlansLoaded extends PlanState {
  const factory PlansLoaded({required final List<PlanEntity> plans}) =
      _$PlansLoadedImpl;
  const PlansLoaded._() : super._();

  List<PlanEntity> get plans;

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PlansLoadedImplCopyWith<_$PlansLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlanSavedImplCopyWith<$Res> {
  factory _$$PlanSavedImplCopyWith(
    _$PlanSavedImpl value,
    $Res Function(_$PlanSavedImpl) then,
  ) = __$$PlanSavedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PlanEntity plan});
}

/// @nodoc
class __$$PlanSavedImplCopyWithImpl<$Res>
    extends _$PlanStateCopyWithImpl<$Res, _$PlanSavedImpl>
    implements _$$PlanSavedImplCopyWith<$Res> {
  __$$PlanSavedImplCopyWithImpl(
    _$PlanSavedImpl _value,
    $Res Function(_$PlanSavedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? plan = null}) {
    return _then(
      _$PlanSavedImpl(
        plan: null == plan
            ? _value.plan
            : plan // ignore: cast_nullable_to_non_nullable
                  as PlanEntity,
      ),
    );
  }
}

/// @nodoc

class _$PlanSavedImpl extends PlanSaved {
  const _$PlanSavedImpl({required this.plan}) : super._();

  @override
  final PlanEntity plan;

  @override
  String toString() {
    return 'PlanState.saved(plan: $plan)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlanSavedImpl &&
            (identical(other.plan, plan) || other.plan == plan));
  }

  @override
  int get hashCode => Object.hash(runtimeType, plan);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PlanSavedImplCopyWith<_$PlanSavedImpl> get copyWith =>
      __$$PlanSavedImplCopyWithImpl<_$PlanSavedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PlanEntity plan) loaded,
    required TResult Function(PlanEntity? plan) saving,
    required TResult Function(PlanEntity? plan) updating,
    required TResult Function(List<PlanEntity> plans) plansLoaded,
    required TResult Function(PlanEntity plan) saved,
    required TResult Function(String message, PlanEntity? plan) error,
  }) {
    return saved(plan);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PlanEntity plan)? loaded,
    TResult? Function(PlanEntity? plan)? saving,
    TResult? Function(PlanEntity? plan)? updating,
    TResult? Function(List<PlanEntity> plans)? plansLoaded,
    TResult? Function(PlanEntity plan)? saved,
    TResult? Function(String message, PlanEntity? plan)? error,
  }) {
    return saved?.call(plan);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PlanEntity plan)? loaded,
    TResult Function(PlanEntity? plan)? saving,
    TResult Function(PlanEntity? plan)? updating,
    TResult Function(List<PlanEntity> plans)? plansLoaded,
    TResult Function(PlanEntity plan)? saved,
    TResult Function(String message, PlanEntity? plan)? error,
    required TResult orElse(),
  }) {
    if (saved != null) {
      return saved(plan);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlanInitial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(PlanLoaded value) loaded,
    required TResult Function(PlanSaving value) saving,
    required TResult Function(PlanUpdating value) updating,
    required TResult Function(PlansLoaded value) plansLoaded,
    required TResult Function(PlanSaved value) saved,
    required TResult Function(PlanError value) error,
  }) {
    return saved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlanInitial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(PlanLoaded value)? loaded,
    TResult? Function(PlanSaving value)? saving,
    TResult? Function(PlanUpdating value)? updating,
    TResult? Function(PlansLoaded value)? plansLoaded,
    TResult? Function(PlanSaved value)? saved,
    TResult? Function(PlanError value)? error,
  }) {
    return saved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlanInitial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(PlanLoaded value)? loaded,
    TResult Function(PlanSaving value)? saving,
    TResult Function(PlanUpdating value)? updating,
    TResult Function(PlansLoaded value)? plansLoaded,
    TResult Function(PlanSaved value)? saved,
    TResult Function(PlanError value)? error,
    required TResult orElse(),
  }) {
    if (saved != null) {
      return saved(this);
    }
    return orElse();
  }
}

abstract class PlanSaved extends PlanState {
  const factory PlanSaved({required final PlanEntity plan}) = _$PlanSavedImpl;
  const PlanSaved._() : super._();

  PlanEntity get plan;

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PlanSavedImplCopyWith<_$PlanSavedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlanErrorImplCopyWith<$Res> {
  factory _$$PlanErrorImplCopyWith(
    _$PlanErrorImpl value,
    $Res Function(_$PlanErrorImpl) then,
  ) = __$$PlanErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message, PlanEntity? plan});
}

/// @nodoc
class __$$PlanErrorImplCopyWithImpl<$Res>
    extends _$PlanStateCopyWithImpl<$Res, _$PlanErrorImpl>
    implements _$$PlanErrorImplCopyWith<$Res> {
  __$$PlanErrorImplCopyWithImpl(
    _$PlanErrorImpl _value,
    $Res Function(_$PlanErrorImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? message = null, Object? plan = freezed}) {
    return _then(
      _$PlanErrorImpl(
        message: null == message
            ? _value.message
            : message // ignore: cast_nullable_to_non_nullable
                  as String,
        plan: freezed == plan
            ? _value.plan
            : plan // ignore: cast_nullable_to_non_nullable
                  as PlanEntity?,
      ),
    );
  }
}

/// @nodoc

class _$PlanErrorImpl extends PlanError {
  const _$PlanErrorImpl({required this.message, this.plan}) : super._();

  @override
  final String message;
  @override
  final PlanEntity? plan;

  @override
  String toString() {
    return 'PlanState.error(message: $message, plan: $plan)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlanErrorImpl &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.plan, plan) || other.plan == plan));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message, plan);

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PlanErrorImplCopyWith<_$PlanErrorImpl> get copyWith =>
      __$$PlanErrorImplCopyWithImpl<_$PlanErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PlanEntity plan) loaded,
    required TResult Function(PlanEntity? plan) saving,
    required TResult Function(PlanEntity? plan) updating,
    required TResult Function(List<PlanEntity> plans) plansLoaded,
    required TResult Function(PlanEntity plan) saved,
    required TResult Function(String message, PlanEntity? plan) error,
  }) {
    return error(message, plan);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PlanEntity plan)? loaded,
    TResult? Function(PlanEntity? plan)? saving,
    TResult? Function(PlanEntity? plan)? updating,
    TResult? Function(List<PlanEntity> plans)? plansLoaded,
    TResult? Function(PlanEntity plan)? saved,
    TResult? Function(String message, PlanEntity? plan)? error,
  }) {
    return error?.call(message, plan);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PlanEntity plan)? loaded,
    TResult Function(PlanEntity? plan)? saving,
    TResult Function(PlanEntity? plan)? updating,
    TResult Function(List<PlanEntity> plans)? plansLoaded,
    TResult Function(PlanEntity plan)? saved,
    TResult Function(String message, PlanEntity? plan)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message, plan);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlanInitial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(PlanLoaded value) loaded,
    required TResult Function(PlanSaving value) saving,
    required TResult Function(PlanUpdating value) updating,
    required TResult Function(PlansLoaded value) plansLoaded,
    required TResult Function(PlanSaved value) saved,
    required TResult Function(PlanError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlanInitial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(PlanLoaded value)? loaded,
    TResult? Function(PlanSaving value)? saving,
    TResult? Function(PlanUpdating value)? updating,
    TResult? Function(PlansLoaded value)? plansLoaded,
    TResult? Function(PlanSaved value)? saved,
    TResult? Function(PlanError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlanInitial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(PlanLoaded value)? loaded,
    TResult Function(PlanSaving value)? saving,
    TResult Function(PlanUpdating value)? updating,
    TResult Function(PlansLoaded value)? plansLoaded,
    TResult Function(PlanSaved value)? saved,
    TResult Function(PlanError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PlanError extends PlanState {
  const factory PlanError({
    required final String message,
    final PlanEntity? plan,
  }) = _$PlanErrorImpl;
  const PlanError._() : super._();

  String get message;
  PlanEntity? get plan;

  /// Create a copy of PlanState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PlanErrorImplCopyWith<_$PlanErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
