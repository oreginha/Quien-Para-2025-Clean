// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'feed_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$FeedState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PlanEntity> plans) refreshing,
    required TResult Function(List<PlanEntity> plans, bool hasReachedEnd)
        paginating,
    required TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)
        loaded,
    required TResult Function(List<PlanEntity> plans, String filterCategory)
        filtered,
    required TResult Function() empty,
    required TResult Function(String message, List<PlanEntity>? plans) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PlanEntity> plans)? refreshing,
    TResult? Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult? Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult? Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult? Function()? empty,
    TResult? Function(String message, List<PlanEntity>? plans)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PlanEntity> plans)? refreshing,
    TResult Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult Function()? empty,
    TResult Function(String message, List<PlanEntity>? plans)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeedInitial value) initial,
    required TResult Function(FeedLoading value) loading,
    required TResult Function(FeedRefreshing value) refreshing,
    required TResult Function(FeedPaginating value) paginating,
    required TResult Function(FeedLoaded value) loaded,
    required TResult Function(FeedFiltered value) filtered,
    required TResult Function(FeedEmpty value) empty,
    required TResult Function(FeedError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeedInitial value)? initial,
    TResult? Function(FeedLoading value)? loading,
    TResult? Function(FeedRefreshing value)? refreshing,
    TResult? Function(FeedPaginating value)? paginating,
    TResult? Function(FeedLoaded value)? loaded,
    TResult? Function(FeedFiltered value)? filtered,
    TResult? Function(FeedEmpty value)? empty,
    TResult? Function(FeedError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeedInitial value)? initial,
    TResult Function(FeedLoading value)? loading,
    TResult Function(FeedRefreshing value)? refreshing,
    TResult Function(FeedPaginating value)? paginating,
    TResult Function(FeedLoaded value)? loaded,
    TResult Function(FeedFiltered value)? filtered,
    TResult Function(FeedEmpty value)? empty,
    TResult Function(FeedError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FeedStateCopyWith<$Res> {
  factory $FeedStateCopyWith(FeedState value, $Res Function(FeedState) then) =
      _$FeedStateCopyWithImpl<$Res, FeedState>;
}

/// @nodoc
class _$FeedStateCopyWithImpl<$Res, $Val extends FeedState>
    implements $FeedStateCopyWith<$Res> {
  _$FeedStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$FeedInitialImplCopyWith<$Res> {
  factory _$$FeedInitialImplCopyWith(
          _$FeedInitialImpl value, $Res Function(_$FeedInitialImpl) then) =
      __$$FeedInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FeedInitialImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$FeedInitialImpl>
    implements _$$FeedInitialImplCopyWith<$Res> {
  __$$FeedInitialImplCopyWithImpl(
      _$FeedInitialImpl _value, $Res Function(_$FeedInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FeedInitialImpl extends FeedInitial {
  const _$FeedInitialImpl() : super._();

  @override
  String toString() {
    return 'FeedState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FeedInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PlanEntity> plans) refreshing,
    required TResult Function(List<PlanEntity> plans, bool hasReachedEnd)
        paginating,
    required TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)
        loaded,
    required TResult Function(List<PlanEntity> plans, String filterCategory)
        filtered,
    required TResult Function() empty,
    required TResult Function(String message, List<PlanEntity>? plans) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PlanEntity> plans)? refreshing,
    TResult? Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult? Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult? Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult? Function()? empty,
    TResult? Function(String message, List<PlanEntity>? plans)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PlanEntity> plans)? refreshing,
    TResult Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult Function()? empty,
    TResult Function(String message, List<PlanEntity>? plans)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeedInitial value) initial,
    required TResult Function(FeedLoading value) loading,
    required TResult Function(FeedRefreshing value) refreshing,
    required TResult Function(FeedPaginating value) paginating,
    required TResult Function(FeedLoaded value) loaded,
    required TResult Function(FeedFiltered value) filtered,
    required TResult Function(FeedEmpty value) empty,
    required TResult Function(FeedError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeedInitial value)? initial,
    TResult? Function(FeedLoading value)? loading,
    TResult? Function(FeedRefreshing value)? refreshing,
    TResult? Function(FeedPaginating value)? paginating,
    TResult? Function(FeedLoaded value)? loaded,
    TResult? Function(FeedFiltered value)? filtered,
    TResult? Function(FeedEmpty value)? empty,
    TResult? Function(FeedError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeedInitial value)? initial,
    TResult Function(FeedLoading value)? loading,
    TResult Function(FeedRefreshing value)? refreshing,
    TResult Function(FeedPaginating value)? paginating,
    TResult Function(FeedLoaded value)? loaded,
    TResult Function(FeedFiltered value)? filtered,
    TResult Function(FeedEmpty value)? empty,
    TResult Function(FeedError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class FeedInitial extends FeedState {
  const factory FeedInitial() = _$FeedInitialImpl;
  const FeedInitial._() : super._();
}

/// @nodoc
abstract class _$$FeedLoadingImplCopyWith<$Res> {
  factory _$$FeedLoadingImplCopyWith(
          _$FeedLoadingImpl value, $Res Function(_$FeedLoadingImpl) then) =
      __$$FeedLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FeedLoadingImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$FeedLoadingImpl>
    implements _$$FeedLoadingImplCopyWith<$Res> {
  __$$FeedLoadingImplCopyWithImpl(
      _$FeedLoadingImpl _value, $Res Function(_$FeedLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FeedLoadingImpl extends FeedLoading {
  const _$FeedLoadingImpl() : super._();

  @override
  String toString() {
    return 'FeedState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FeedLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PlanEntity> plans) refreshing,
    required TResult Function(List<PlanEntity> plans, bool hasReachedEnd)
        paginating,
    required TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)
        loaded,
    required TResult Function(List<PlanEntity> plans, String filterCategory)
        filtered,
    required TResult Function() empty,
    required TResult Function(String message, List<PlanEntity>? plans) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PlanEntity> plans)? refreshing,
    TResult? Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult? Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult? Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult? Function()? empty,
    TResult? Function(String message, List<PlanEntity>? plans)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PlanEntity> plans)? refreshing,
    TResult Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult Function()? empty,
    TResult Function(String message, List<PlanEntity>? plans)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeedInitial value) initial,
    required TResult Function(FeedLoading value) loading,
    required TResult Function(FeedRefreshing value) refreshing,
    required TResult Function(FeedPaginating value) paginating,
    required TResult Function(FeedLoaded value) loaded,
    required TResult Function(FeedFiltered value) filtered,
    required TResult Function(FeedEmpty value) empty,
    required TResult Function(FeedError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeedInitial value)? initial,
    TResult? Function(FeedLoading value)? loading,
    TResult? Function(FeedRefreshing value)? refreshing,
    TResult? Function(FeedPaginating value)? paginating,
    TResult? Function(FeedLoaded value)? loaded,
    TResult? Function(FeedFiltered value)? filtered,
    TResult? Function(FeedEmpty value)? empty,
    TResult? Function(FeedError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeedInitial value)? initial,
    TResult Function(FeedLoading value)? loading,
    TResult Function(FeedRefreshing value)? refreshing,
    TResult Function(FeedPaginating value)? paginating,
    TResult Function(FeedLoaded value)? loaded,
    TResult Function(FeedFiltered value)? filtered,
    TResult Function(FeedEmpty value)? empty,
    TResult Function(FeedError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class FeedLoading extends FeedState {
  const factory FeedLoading() = _$FeedLoadingImpl;
  const FeedLoading._() : super._();
}

/// @nodoc
abstract class _$$FeedRefreshingImplCopyWith<$Res> {
  factory _$$FeedRefreshingImplCopyWith(_$FeedRefreshingImpl value,
          $Res Function(_$FeedRefreshingImpl) then) =
      __$$FeedRefreshingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<PlanEntity> plans});
}

/// @nodoc
class __$$FeedRefreshingImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$FeedRefreshingImpl>
    implements _$$FeedRefreshingImplCopyWith<$Res> {
  __$$FeedRefreshingImplCopyWithImpl(
      _$FeedRefreshingImpl _value, $Res Function(_$FeedRefreshingImpl) _then)
      : super(_value, _then);

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? plans = null,
  }) {
    return _then(_$FeedRefreshingImpl(
      plans: null == plans
          ? _value._plans
          : plans // ignore: cast_nullable_to_non_nullable
              as List<PlanEntity>,
    ));
  }
}

/// @nodoc

class _$FeedRefreshingImpl extends FeedRefreshing {
  const _$FeedRefreshingImpl({required final List<PlanEntity> plans})
      : _plans = plans,
        super._();

  final List<PlanEntity> _plans;
  @override
  List<PlanEntity> get plans {
    if (_plans is EqualUnmodifiableListView) return _plans;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_plans);
  }

  @override
  String toString() {
    return 'FeedState.refreshing(plans: $plans)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeedRefreshingImpl &&
            const DeepCollectionEquality().equals(other._plans, _plans));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_plans));

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FeedRefreshingImplCopyWith<_$FeedRefreshingImpl> get copyWith =>
      __$$FeedRefreshingImplCopyWithImpl<_$FeedRefreshingImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PlanEntity> plans) refreshing,
    required TResult Function(List<PlanEntity> plans, bool hasReachedEnd)
        paginating,
    required TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)
        loaded,
    required TResult Function(List<PlanEntity> plans, String filterCategory)
        filtered,
    required TResult Function() empty,
    required TResult Function(String message, List<PlanEntity>? plans) error,
  }) {
    return refreshing(plans);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PlanEntity> plans)? refreshing,
    TResult? Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult? Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult? Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult? Function()? empty,
    TResult? Function(String message, List<PlanEntity>? plans)? error,
  }) {
    return refreshing?.call(plans);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PlanEntity> plans)? refreshing,
    TResult Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult Function()? empty,
    TResult Function(String message, List<PlanEntity>? plans)? error,
    required TResult orElse(),
  }) {
    if (refreshing != null) {
      return refreshing(plans);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeedInitial value) initial,
    required TResult Function(FeedLoading value) loading,
    required TResult Function(FeedRefreshing value) refreshing,
    required TResult Function(FeedPaginating value) paginating,
    required TResult Function(FeedLoaded value) loaded,
    required TResult Function(FeedFiltered value) filtered,
    required TResult Function(FeedEmpty value) empty,
    required TResult Function(FeedError value) error,
  }) {
    return refreshing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeedInitial value)? initial,
    TResult? Function(FeedLoading value)? loading,
    TResult? Function(FeedRefreshing value)? refreshing,
    TResult? Function(FeedPaginating value)? paginating,
    TResult? Function(FeedLoaded value)? loaded,
    TResult? Function(FeedFiltered value)? filtered,
    TResult? Function(FeedEmpty value)? empty,
    TResult? Function(FeedError value)? error,
  }) {
    return refreshing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeedInitial value)? initial,
    TResult Function(FeedLoading value)? loading,
    TResult Function(FeedRefreshing value)? refreshing,
    TResult Function(FeedPaginating value)? paginating,
    TResult Function(FeedLoaded value)? loaded,
    TResult Function(FeedFiltered value)? filtered,
    TResult Function(FeedEmpty value)? empty,
    TResult Function(FeedError value)? error,
    required TResult orElse(),
  }) {
    if (refreshing != null) {
      return refreshing(this);
    }
    return orElse();
  }
}

abstract class FeedRefreshing extends FeedState {
  const factory FeedRefreshing({required final List<PlanEntity> plans}) =
      _$FeedRefreshingImpl;
  const FeedRefreshing._() : super._();

  List<PlanEntity> get plans;

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FeedRefreshingImplCopyWith<_$FeedRefreshingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FeedPaginatingImplCopyWith<$Res> {
  factory _$$FeedPaginatingImplCopyWith(_$FeedPaginatingImpl value,
          $Res Function(_$FeedPaginatingImpl) then) =
      __$$FeedPaginatingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<PlanEntity> plans, bool hasReachedEnd});
}

/// @nodoc
class __$$FeedPaginatingImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$FeedPaginatingImpl>
    implements _$$FeedPaginatingImplCopyWith<$Res> {
  __$$FeedPaginatingImplCopyWithImpl(
      _$FeedPaginatingImpl _value, $Res Function(_$FeedPaginatingImpl) _then)
      : super(_value, _then);

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? plans = null,
    Object? hasReachedEnd = null,
  }) {
    return _then(_$FeedPaginatingImpl(
      plans: null == plans
          ? _value._plans
          : plans // ignore: cast_nullable_to_non_nullable
              as List<PlanEntity>,
      hasReachedEnd: null == hasReachedEnd
          ? _value.hasReachedEnd
          : hasReachedEnd // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$FeedPaginatingImpl extends FeedPaginating {
  const _$FeedPaginatingImpl(
      {required final List<PlanEntity> plans, required this.hasReachedEnd})
      : _plans = plans,
        super._();

  final List<PlanEntity> _plans;
  @override
  List<PlanEntity> get plans {
    if (_plans is EqualUnmodifiableListView) return _plans;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_plans);
  }

  @override
  final bool hasReachedEnd;

  @override
  String toString() {
    return 'FeedState.paginating(plans: $plans, hasReachedEnd: $hasReachedEnd)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeedPaginatingImpl &&
            const DeepCollectionEquality().equals(other._plans, _plans) &&
            (identical(other.hasReachedEnd, hasReachedEnd) ||
                other.hasReachedEnd == hasReachedEnd));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_plans), hasReachedEnd);

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FeedPaginatingImplCopyWith<_$FeedPaginatingImpl> get copyWith =>
      __$$FeedPaginatingImplCopyWithImpl<_$FeedPaginatingImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PlanEntity> plans) refreshing,
    required TResult Function(List<PlanEntity> plans, bool hasReachedEnd)
        paginating,
    required TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)
        loaded,
    required TResult Function(List<PlanEntity> plans, String filterCategory)
        filtered,
    required TResult Function() empty,
    required TResult Function(String message, List<PlanEntity>? plans) error,
  }) {
    return paginating(plans, hasReachedEnd);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PlanEntity> plans)? refreshing,
    TResult? Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult? Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult? Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult? Function()? empty,
    TResult? Function(String message, List<PlanEntity>? plans)? error,
  }) {
    return paginating?.call(plans, hasReachedEnd);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PlanEntity> plans)? refreshing,
    TResult Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult Function()? empty,
    TResult Function(String message, List<PlanEntity>? plans)? error,
    required TResult orElse(),
  }) {
    if (paginating != null) {
      return paginating(plans, hasReachedEnd);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeedInitial value) initial,
    required TResult Function(FeedLoading value) loading,
    required TResult Function(FeedRefreshing value) refreshing,
    required TResult Function(FeedPaginating value) paginating,
    required TResult Function(FeedLoaded value) loaded,
    required TResult Function(FeedFiltered value) filtered,
    required TResult Function(FeedEmpty value) empty,
    required TResult Function(FeedError value) error,
  }) {
    return paginating(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeedInitial value)? initial,
    TResult? Function(FeedLoading value)? loading,
    TResult? Function(FeedRefreshing value)? refreshing,
    TResult? Function(FeedPaginating value)? paginating,
    TResult? Function(FeedLoaded value)? loaded,
    TResult? Function(FeedFiltered value)? filtered,
    TResult? Function(FeedEmpty value)? empty,
    TResult? Function(FeedError value)? error,
  }) {
    return paginating?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeedInitial value)? initial,
    TResult Function(FeedLoading value)? loading,
    TResult Function(FeedRefreshing value)? refreshing,
    TResult Function(FeedPaginating value)? paginating,
    TResult Function(FeedLoaded value)? loaded,
    TResult Function(FeedFiltered value)? filtered,
    TResult Function(FeedEmpty value)? empty,
    TResult Function(FeedError value)? error,
    required TResult orElse(),
  }) {
    if (paginating != null) {
      return paginating(this);
    }
    return orElse();
  }
}

abstract class FeedPaginating extends FeedState {
  const factory FeedPaginating(
      {required final List<PlanEntity> plans,
      required final bool hasReachedEnd}) = _$FeedPaginatingImpl;
  const FeedPaginating._() : super._();

  List<PlanEntity> get plans;
  bool get hasReachedEnd;

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FeedPaginatingImplCopyWith<_$FeedPaginatingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FeedLoadedImplCopyWith<$Res> {
  factory _$$FeedLoadedImplCopyWith(
          _$FeedLoadedImpl value, $Res Function(_$FeedLoadedImpl) then) =
      __$$FeedLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId});
}

/// @nodoc
class __$$FeedLoadedImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$FeedLoadedImpl>
    implements _$$FeedLoadedImplCopyWith<$Res> {
  __$$FeedLoadedImplCopyWithImpl(
      _$FeedLoadedImpl _value, $Res Function(_$FeedLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? plans = null,
    Object? hasReachedEnd = null,
    Object? lastDocumentId = freezed,
  }) {
    return _then(_$FeedLoadedImpl(
      plans: null == plans
          ? _value._plans
          : plans // ignore: cast_nullable_to_non_nullable
              as List<PlanEntity>,
      hasReachedEnd: null == hasReachedEnd
          ? _value.hasReachedEnd
          : hasReachedEnd // ignore: cast_nullable_to_non_nullable
              as bool,
      lastDocumentId: freezed == lastDocumentId
          ? _value.lastDocumentId
          : lastDocumentId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$FeedLoadedImpl extends FeedLoaded {
  const _$FeedLoadedImpl(
      {required final List<PlanEntity> plans,
      this.hasReachedEnd = false,
      this.lastDocumentId})
      : _plans = plans,
        super._();

  final List<PlanEntity> _plans;
  @override
  List<PlanEntity> get plans {
    if (_plans is EqualUnmodifiableListView) return _plans;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_plans);
  }

  @override
  @JsonKey()
  final bool hasReachedEnd;
  @override
  final String? lastDocumentId;

  @override
  String toString() {
    return 'FeedState.loaded(plans: $plans, hasReachedEnd: $hasReachedEnd, lastDocumentId: $lastDocumentId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeedLoadedImpl &&
            const DeepCollectionEquality().equals(other._plans, _plans) &&
            (identical(other.hasReachedEnd, hasReachedEnd) ||
                other.hasReachedEnd == hasReachedEnd) &&
            (identical(other.lastDocumentId, lastDocumentId) ||
                other.lastDocumentId == lastDocumentId));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_plans),
      hasReachedEnd,
      lastDocumentId);

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FeedLoadedImplCopyWith<_$FeedLoadedImpl> get copyWith =>
      __$$FeedLoadedImplCopyWithImpl<_$FeedLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PlanEntity> plans) refreshing,
    required TResult Function(List<PlanEntity> plans, bool hasReachedEnd)
        paginating,
    required TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)
        loaded,
    required TResult Function(List<PlanEntity> plans, String filterCategory)
        filtered,
    required TResult Function() empty,
    required TResult Function(String message, List<PlanEntity>? plans) error,
  }) {
    return loaded(plans, hasReachedEnd, lastDocumentId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PlanEntity> plans)? refreshing,
    TResult? Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult? Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult? Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult? Function()? empty,
    TResult? Function(String message, List<PlanEntity>? plans)? error,
  }) {
    return loaded?.call(plans, hasReachedEnd, lastDocumentId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PlanEntity> plans)? refreshing,
    TResult Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult Function()? empty,
    TResult Function(String message, List<PlanEntity>? plans)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(plans, hasReachedEnd, lastDocumentId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeedInitial value) initial,
    required TResult Function(FeedLoading value) loading,
    required TResult Function(FeedRefreshing value) refreshing,
    required TResult Function(FeedPaginating value) paginating,
    required TResult Function(FeedLoaded value) loaded,
    required TResult Function(FeedFiltered value) filtered,
    required TResult Function(FeedEmpty value) empty,
    required TResult Function(FeedError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeedInitial value)? initial,
    TResult? Function(FeedLoading value)? loading,
    TResult? Function(FeedRefreshing value)? refreshing,
    TResult? Function(FeedPaginating value)? paginating,
    TResult? Function(FeedLoaded value)? loaded,
    TResult? Function(FeedFiltered value)? filtered,
    TResult? Function(FeedEmpty value)? empty,
    TResult? Function(FeedError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeedInitial value)? initial,
    TResult Function(FeedLoading value)? loading,
    TResult Function(FeedRefreshing value)? refreshing,
    TResult Function(FeedPaginating value)? paginating,
    TResult Function(FeedLoaded value)? loaded,
    TResult Function(FeedFiltered value)? filtered,
    TResult Function(FeedEmpty value)? empty,
    TResult Function(FeedError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class FeedLoaded extends FeedState {
  const factory FeedLoaded(
      {required final List<PlanEntity> plans,
      final bool hasReachedEnd,
      final String? lastDocumentId}) = _$FeedLoadedImpl;
  const FeedLoaded._() : super._();

  List<PlanEntity> get plans;
  bool get hasReachedEnd;
  String? get lastDocumentId;

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FeedLoadedImplCopyWith<_$FeedLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FeedFilteredImplCopyWith<$Res> {
  factory _$$FeedFilteredImplCopyWith(
          _$FeedFilteredImpl value, $Res Function(_$FeedFilteredImpl) then) =
      __$$FeedFilteredImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<PlanEntity> plans, String filterCategory});
}

/// @nodoc
class __$$FeedFilteredImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$FeedFilteredImpl>
    implements _$$FeedFilteredImplCopyWith<$Res> {
  __$$FeedFilteredImplCopyWithImpl(
      _$FeedFilteredImpl _value, $Res Function(_$FeedFilteredImpl) _then)
      : super(_value, _then);

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? plans = null,
    Object? filterCategory = null,
  }) {
    return _then(_$FeedFilteredImpl(
      plans: null == plans
          ? _value._plans
          : plans // ignore: cast_nullable_to_non_nullable
              as List<PlanEntity>,
      filterCategory: null == filterCategory
          ? _value.filterCategory
          : filterCategory // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FeedFilteredImpl extends FeedFiltered {
  const _$FeedFilteredImpl(
      {required final List<PlanEntity> plans, required this.filterCategory})
      : _plans = plans,
        super._();

  final List<PlanEntity> _plans;
  @override
  List<PlanEntity> get plans {
    if (_plans is EqualUnmodifiableListView) return _plans;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_plans);
  }

  @override
  final String filterCategory;

  @override
  String toString() {
    return 'FeedState.filtered(plans: $plans, filterCategory: $filterCategory)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeedFilteredImpl &&
            const DeepCollectionEquality().equals(other._plans, _plans) &&
            (identical(other.filterCategory, filterCategory) ||
                other.filterCategory == filterCategory));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_plans), filterCategory);

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FeedFilteredImplCopyWith<_$FeedFilteredImpl> get copyWith =>
      __$$FeedFilteredImplCopyWithImpl<_$FeedFilteredImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PlanEntity> plans) refreshing,
    required TResult Function(List<PlanEntity> plans, bool hasReachedEnd)
        paginating,
    required TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)
        loaded,
    required TResult Function(List<PlanEntity> plans, String filterCategory)
        filtered,
    required TResult Function() empty,
    required TResult Function(String message, List<PlanEntity>? plans) error,
  }) {
    return filtered(plans, filterCategory);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PlanEntity> plans)? refreshing,
    TResult? Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult? Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult? Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult? Function()? empty,
    TResult? Function(String message, List<PlanEntity>? plans)? error,
  }) {
    return filtered?.call(plans, filterCategory);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PlanEntity> plans)? refreshing,
    TResult Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult Function()? empty,
    TResult Function(String message, List<PlanEntity>? plans)? error,
    required TResult orElse(),
  }) {
    if (filtered != null) {
      return filtered(plans, filterCategory);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeedInitial value) initial,
    required TResult Function(FeedLoading value) loading,
    required TResult Function(FeedRefreshing value) refreshing,
    required TResult Function(FeedPaginating value) paginating,
    required TResult Function(FeedLoaded value) loaded,
    required TResult Function(FeedFiltered value) filtered,
    required TResult Function(FeedEmpty value) empty,
    required TResult Function(FeedError value) error,
  }) {
    return filtered(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeedInitial value)? initial,
    TResult? Function(FeedLoading value)? loading,
    TResult? Function(FeedRefreshing value)? refreshing,
    TResult? Function(FeedPaginating value)? paginating,
    TResult? Function(FeedLoaded value)? loaded,
    TResult? Function(FeedFiltered value)? filtered,
    TResult? Function(FeedEmpty value)? empty,
    TResult? Function(FeedError value)? error,
  }) {
    return filtered?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeedInitial value)? initial,
    TResult Function(FeedLoading value)? loading,
    TResult Function(FeedRefreshing value)? refreshing,
    TResult Function(FeedPaginating value)? paginating,
    TResult Function(FeedLoaded value)? loaded,
    TResult Function(FeedFiltered value)? filtered,
    TResult Function(FeedEmpty value)? empty,
    TResult Function(FeedError value)? error,
    required TResult orElse(),
  }) {
    if (filtered != null) {
      return filtered(this);
    }
    return orElse();
  }
}

abstract class FeedFiltered extends FeedState {
  const factory FeedFiltered(
      {required final List<PlanEntity> plans,
      required final String filterCategory}) = _$FeedFilteredImpl;
  const FeedFiltered._() : super._();

  List<PlanEntity> get plans;
  String get filterCategory;

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FeedFilteredImplCopyWith<_$FeedFilteredImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FeedEmptyImplCopyWith<$Res> {
  factory _$$FeedEmptyImplCopyWith(
          _$FeedEmptyImpl value, $Res Function(_$FeedEmptyImpl) then) =
      __$$FeedEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FeedEmptyImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$FeedEmptyImpl>
    implements _$$FeedEmptyImplCopyWith<$Res> {
  __$$FeedEmptyImplCopyWithImpl(
      _$FeedEmptyImpl _value, $Res Function(_$FeedEmptyImpl) _then)
      : super(_value, _then);

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FeedEmptyImpl extends FeedEmpty {
  const _$FeedEmptyImpl() : super._();

  @override
  String toString() {
    return 'FeedState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FeedEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PlanEntity> plans) refreshing,
    required TResult Function(List<PlanEntity> plans, bool hasReachedEnd)
        paginating,
    required TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)
        loaded,
    required TResult Function(List<PlanEntity> plans, String filterCategory)
        filtered,
    required TResult Function() empty,
    required TResult Function(String message, List<PlanEntity>? plans) error,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PlanEntity> plans)? refreshing,
    TResult? Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult? Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult? Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult? Function()? empty,
    TResult? Function(String message, List<PlanEntity>? plans)? error,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PlanEntity> plans)? refreshing,
    TResult Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult Function()? empty,
    TResult Function(String message, List<PlanEntity>? plans)? error,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeedInitial value) initial,
    required TResult Function(FeedLoading value) loading,
    required TResult Function(FeedRefreshing value) refreshing,
    required TResult Function(FeedPaginating value) paginating,
    required TResult Function(FeedLoaded value) loaded,
    required TResult Function(FeedFiltered value) filtered,
    required TResult Function(FeedEmpty value) empty,
    required TResult Function(FeedError value) error,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeedInitial value)? initial,
    TResult? Function(FeedLoading value)? loading,
    TResult? Function(FeedRefreshing value)? refreshing,
    TResult? Function(FeedPaginating value)? paginating,
    TResult? Function(FeedLoaded value)? loaded,
    TResult? Function(FeedFiltered value)? filtered,
    TResult? Function(FeedEmpty value)? empty,
    TResult? Function(FeedError value)? error,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeedInitial value)? initial,
    TResult Function(FeedLoading value)? loading,
    TResult Function(FeedRefreshing value)? refreshing,
    TResult Function(FeedPaginating value)? paginating,
    TResult Function(FeedLoaded value)? loaded,
    TResult Function(FeedFiltered value)? filtered,
    TResult Function(FeedEmpty value)? empty,
    TResult Function(FeedError value)? error,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class FeedEmpty extends FeedState {
  const factory FeedEmpty() = _$FeedEmptyImpl;
  const FeedEmpty._() : super._();
}

/// @nodoc
abstract class _$$FeedErrorImplCopyWith<$Res> {
  factory _$$FeedErrorImplCopyWith(
          _$FeedErrorImpl value, $Res Function(_$FeedErrorImpl) then) =
      __$$FeedErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message, List<PlanEntity>? plans});
}

/// @nodoc
class __$$FeedErrorImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$FeedErrorImpl>
    implements _$$FeedErrorImplCopyWith<$Res> {
  __$$FeedErrorImplCopyWithImpl(
      _$FeedErrorImpl _value, $Res Function(_$FeedErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? plans = freezed,
  }) {
    return _then(_$FeedErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      plans: freezed == plans
          ? _value._plans
          : plans // ignore: cast_nullable_to_non_nullable
              as List<PlanEntity>?,
    ));
  }
}

/// @nodoc

class _$FeedErrorImpl extends FeedError {
  const _$FeedErrorImpl({required this.message, final List<PlanEntity>? plans})
      : _plans = plans,
        super._();

  @override
  final String message;
  final List<PlanEntity>? _plans;
  @override
  List<PlanEntity>? get plans {
    final value = _plans;
    if (value == null) return null;
    if (_plans is EqualUnmodifiableListView) return _plans;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'FeedState.error(message: $message, plans: $plans)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeedErrorImpl &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._plans, _plans));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, message, const DeepCollectionEquality().hash(_plans));

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FeedErrorImplCopyWith<_$FeedErrorImpl> get copyWith =>
      __$$FeedErrorImplCopyWithImpl<_$FeedErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PlanEntity> plans) refreshing,
    required TResult Function(List<PlanEntity> plans, bool hasReachedEnd)
        paginating,
    required TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)
        loaded,
    required TResult Function(List<PlanEntity> plans, String filterCategory)
        filtered,
    required TResult Function() empty,
    required TResult Function(String message, List<PlanEntity>? plans) error,
  }) {
    return error(message, plans);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PlanEntity> plans)? refreshing,
    TResult? Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult? Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult? Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult? Function()? empty,
    TResult? Function(String message, List<PlanEntity>? plans)? error,
  }) {
    return error?.call(message, plans);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PlanEntity> plans)? refreshing,
    TResult Function(List<PlanEntity> plans, bool hasReachedEnd)? paginating,
    TResult Function(
            List<PlanEntity> plans, bool hasReachedEnd, String? lastDocumentId)?
        loaded,
    TResult Function(List<PlanEntity> plans, String filterCategory)? filtered,
    TResult Function()? empty,
    TResult Function(String message, List<PlanEntity>? plans)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message, plans);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeedInitial value) initial,
    required TResult Function(FeedLoading value) loading,
    required TResult Function(FeedRefreshing value) refreshing,
    required TResult Function(FeedPaginating value) paginating,
    required TResult Function(FeedLoaded value) loaded,
    required TResult Function(FeedFiltered value) filtered,
    required TResult Function(FeedEmpty value) empty,
    required TResult Function(FeedError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeedInitial value)? initial,
    TResult? Function(FeedLoading value)? loading,
    TResult? Function(FeedRefreshing value)? refreshing,
    TResult? Function(FeedPaginating value)? paginating,
    TResult? Function(FeedLoaded value)? loaded,
    TResult? Function(FeedFiltered value)? filtered,
    TResult? Function(FeedEmpty value)? empty,
    TResult? Function(FeedError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeedInitial value)? initial,
    TResult Function(FeedLoading value)? loading,
    TResult Function(FeedRefreshing value)? refreshing,
    TResult Function(FeedPaginating value)? paginating,
    TResult Function(FeedLoaded value)? loaded,
    TResult Function(FeedFiltered value)? filtered,
    TResult Function(FeedEmpty value)? empty,
    TResult Function(FeedError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class FeedError extends FeedState {
  const factory FeedError(
      {required final String message,
      final List<PlanEntity>? plans}) = _$FeedErrorImpl;
  const FeedError._() : super._();

  String get message;
  List<PlanEntity>? get plans;

  /// Create a copy of FeedState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FeedErrorImplCopyWith<_$FeedErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
